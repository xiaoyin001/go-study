# 常用问题准备

## Go相关知识
### 1、Go语言相对其他语言的优势在哪里？ / Go语言的特性有哪些？
- 性能优越：Go是编译行语言，相对其他解释行语言，速度更快
- 并发能力强：Go原生支持并发编程，轻量的goroutine让其在处理并发任务时表现出色
- 静态类型：Go是静态类型语言，在编译时就能发现一些潜在的错误，提高了代码的可靠性
- 丰富的库：Go内置了丰富的标准库和第三方库，方便开发者进行开发
- 跨平台：开发者在一个平台上写的代码，可以拿到多个平台上进行编译运行
- 简洁易读：Go语言的语法简洁统一的代码风格，易于学习、阅读和理解
- 内存安全：Go语言的运行时包含一个垃圾回收器，可以自动管理内存，减少了内存泄漏的风险
- 高效编译：Go语言的编译速度很快，可以快速的构建运行测试代码

### 2、Go语言的优缺点分别是什么？
- 优点：语法简单、并发性能强、跨平台、丰富的库
- 缺点：大部分包都是在github上，归个人所有，没有官方组织维护

### 3、Go语言中什么是死锁？
- 多个协程之间互相等待对方释放锁，导致程序无法继续执行
- 简单来讲，就是每个进程都占用了一部分资源，同时需要等待对方释放资源，以完成自己的任务，
  但是对方也一样，这时候就会造成死循环式的等待，进而导致整个系统崩溃。

### 4、Go语言如何避免死锁？
- 尽可能减少锁的持有时间
- 使用channel进行协程之间的同步和通信
- 使用select语句来避免通道阻塞

### 5、Go语言中的channel，它在goroutine之间的通信中扮演什么角色？
- channel是Go语言中的一种特殊的数据结构，用于在goroutine之间进行通信和同步
- channel可以用于传递数据、信号、错误等
- channel可以用于协程之间的同步和通信

### 6、Go语言中的select语句它与switch语句有什么不同？
- select语句用于处理多个通道操作，类似于switch语句用于处理多个条件表达式。
  但是，select语句是专门为通道设计的，用于在多个通道操作之间进行选择执行
- select语句会阻塞，直到其中一个通道操作准备好执行
- 如果多个通道操作同时准备好，select语句会随机选择一个执行
- select语句只能用于通道操作，而switch语句可以用于任何可以比较的值
- select语句中的每个case必须是一个通道操作，可以是接收操作（<-channel）
  或发送操作（channel <- value），而switch语句的case可以是任何表达式

### 7、Go语言的垃圾回收机制是怎样的？
- 三色标记标记算法来标记垃圾对象
- 1.在扫描前，所有对象都是白色，默认是不可达
- 2.从根节点出发，扫描所有可达对象，把扫描到的对象标记成灰色，并放入待处理队列
- 3.从待处理队列中取出灰色对象，扫描灰色对象的字段，把扫描到的引用对象放入待处理队列，然后把自己标记成黑色
- 4.重复步骤3，直到待处理队列为空，所有可达对象都被标记成黑色
- 5.所有未被标记成黑色的对象都是垃圾对象，可以被回收

### 8、Go语言的并发模型是怎样的？
- 基于CSP（Communicating Sequential Processes）理论，该理论的核心思想是通过通信来共享内存，而不是通过共享内存来通信

### 9、Go语言的并发调度模型是怎样的？
- 并发调度模型是基于GMP模型实现的
- G代表Goroutine，是对一个要并发执行的任务进行的封装
- M代表内核线程，直接关联了一个内核线程，用于执行G中的并发任务
- P用来管理G对象，P挂载在M下，G队列挂载在P下

### 10、描述一下Go语言中的map和slice
- map是一种无序的键值对集合，可以存储任意类型的键值对，并且键是唯一的
- map的查找、插入和删除操作都非常快速，时间复杂度为O(1)
- map不保证元素的顺序，每次迭代map时，元素的顺序都可能不同
- slice是对数组的抽象和控制，它包含了指向底层数组的指针、slice中元素的长度以及slice的容量
- slice是对底层数组的封装，提供了更加灵活和方便的操作方式

### 11、Go语言中panic和recover处理异常
- panic函数会引发一个运行时恐慌，它会停止当前函数的执行，并开始逐层向上退出栈，
  直到被recover捕获或者达到程序的顶层并导致程序崩溃
- recover函数可以捕获panic产生的恐慌，并恢复程序的正常执行流程
- recover只能在defer函数中有效

### 12、sync.map的原理
- 通过read和dirty两个字段将读写分离，读的数据存在只读字段read上，将最新写入的数据存在dirty字段上。
  读取时会先查询read，不存在再查询dirty，写入时只写入dirty，当达到同步的条件时，将dirty的数据同步到read中

### 13、go中如何判断两个interface{}相等
- 使用 reflect 包中的类型和值的比较，先判断类型是否相等，再判断值是否相等


## TPC、UDP相关知识
### 1、请解释TCP（传输控制协议）是什么？以及它在网络中的作用
- TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议
- TCP在网络中的作用，可以比喻为一座庞大的桥梁，连接着网络中的各个终端，保证数据的顺利、安全和有序地传输

### 2、TCP的三次握手和四次挥手是什么？它们的作用是什么？
- TCP的三次握手和四次挥手是TCP协议建立连接和断开连接的过程
- 三次握手是指建立一个TCP连接时，需要客户端与服务器总共发送3个包以确认双方的发送能力与接收能力是否正常
    - 第一次握手：客户端向服务端发送消息a
    - 第二次握手：服务器接受到消息a后，向客户端发送消息b（第二次握手可以确定 客户端的发送 和 服务器的接收 是正常的）
    - 第三次握手：客户端接受到消息b后，向服务器发送消息c（第三次握手可以确定 客户端的接收 和 服务器的发送 是正常的）
    - 此时，TCP连接已经建立，客户端和服务器可以开始传输数据
- 四次挥手是指断开一个TCP连接时，需要客户端与服务器总共发送4个包，以保证双方都同意断开连接
    - 第一次挥手：客户端向服务器发送消息a，表示客户端要断开连接（客户端跟服务器表达，该说的都已经说完了，我要准备撤了）
    - 第二次挥手：服务器接受到消息a后，向客户端发送消息b，表示服务器同意断开连接
      （服务器收到了客户端要撤的消息，就回复：好的，我知道你要准备撤了）
    - 这个间隙，服务器可能还有数据要发送给客户端，所以服务器会继续发送数据，直到数据发送完毕
    - 第三次挥手：服务器向客户端发送消息c，表示服务器即将断开连接
      （到这里服务器接着又说：我该说的也都说了，既然要撤那就撤吧，我也要撤了）
    - 第四次挥手：客户端接受到消息c后，向服务器发送消息d，表示客户端同意断开连接（客户端会了一句：溜了，拜拜）
    - 此时，TCP连接已经断开，客户端和服务器可以开始新的连接

### 3、TCP和UDP的主要区别是什么？
- 可靠性：
    - TCP提供可靠的数据传输，保证数据的完整性和有序性
    - UDP是无连接的协议，不提供可靠交付
- 速度：TCP相对UDP更加复杂，在传输效率上稍低一些
- 连接性：
    - TCP是面向连接的协议，它通过建立连接来进行数据传输
    - UDP是无连接的协议，可以直接发送数据
- 数据包大小：
    - TCP在传输数据时，将数据分割成较小的数据块，并根据网络状况调整数据块的大小
    - UDP的数据包大小没有限制
- 应用场景：
    - TCP一般用于文件传输、远程登录等场景
    - UDP一般用于即时通信的服务，如语音、视频等


## 数据结构相关
### 1、常见的二叉树有哪些？
- 满二叉树：所有的节点都有左右两个子节点（除叶子节点外）
- 完全二叉树：所有的叶子界面不在最后一层就是在倒数第二层，且叶子界面都是从左到右连续分布的
- 平衡二叉树（AVL树）：左右子树的绝对高度差不超过1
- 二叉搜索树：左子树的所有节点的值都小于根节点的值，右子树的所有节点的值都大于根节点的值，他们的左右节点也都是二叉搜索树
- 红黑树：
    - 节点是红色或黑色
    - 根节点是黑色
    - 每个叶子节点（NIL）是黑色。[注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
    - 红色节点的子节点必须是黑色的
    - 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点

### 2、讲一下二叉树的 前序遍历、中序遍历、后续遍历
- https://blog.csdn.net/chengyq116/article/details/105080920/
- 前序遍历：根节点 -> 左子树 -> 右子树
- 中序遍历：左子树 -> 根节点 -> 右子树
- 后序遍历：左子树 -> 右子树 -> 根节点


## 排序算法相关
### 1、常见的排序算法有哪些？
- https://www.runoob.com/w3cnote/ten-sorting-algorithm.html
- 冒泡排序：相邻元素两两比较，将较大的元素交换到右边
- 选择排序：每次找到未确定顺序部分中的最小元素，将其放到已确定顺序部分的末尾
- 插入排序：拿一个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
- 快速排序：通过选择一个基准元素，将所有其他元素分为两个分区，并递归地对两个分区进行排序
           （所有都分成不超过2个数的部分，然后进行排序，将排序后的数组向上传递，一直到数组完全排序）


## 数据库相关
### 1、MySQL的事务隔离级别，可重复读是什么样的概念？
- MySQL的事务隔离级别中的可重复读是指，在同一事务中进行多次查询时，会返回第一次查询时的快照，而不是实时的最新值

### 2、MySQL联合索引最左匹配原则
- 联合索引顾名思义，就是同时索引多个列的一种索引类型
- 根据联合索引的顺序，从左往右依次匹配，匹配到第一个不匹配的列，就停止匹配，然后进行回表查询
- 如果需要范围查询如（BETWEEN、<、>等）当前字段索引任然生效，但是从下个字段开始，索引将失效
- 最左匹配原则的意义在于它可以帮助我们更好地理解何时以及如何使用联合索引，以及如何避免不必要的全表扫描

### 3、Redis的数据类型？
- 支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset（sorted set：有序集合

### 4、Redis持久化的方式
- RDB（Redis DataBase）：在指定的时间间隔内将内存中的数据集以快照的方式写入到二进制文件中，恢复时是将快照文件直接读到内存里
- AOF（Append Only File）：采用日志的形式来记录每个写操作，并追加到AOF文件的末尾，每次操作都会写入日志。当需要恢复数据时，可以根据日志的记录完整地走一遍流程，恢复数据
- 同时开启两种持久化方式，AOF文件将作为主文件，RDB文件将只作为备份文件出现

### 5、Redis的过期策略
- 定期删除：每隔一段时间，扫描一定数量的数据库键，并随机抽取一定数量的数据库键，删除其中的过期键
- 惰性删除：当访问一个键时，如果发现该键已过期，那么立即进行删除

### 6、MySQL的聚簇索引和非聚簇索引的区别？
- 数据存储：
    - 聚簇索引将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据
    - 非聚簇索引：将数据和索引分开存储，索引结构的叶子节点指向了数据行的地址
- 唯一性：聚簇索引一个表只能有一个聚簇索引；非聚簇索引一个表可以有多个非聚簇索引
- 性能：
    - 聚簇索引：查询效率相对高,增删改数据效率相对低
    - 非聚簇索引：查询效率相对低，增删改数据效率相对高

### 7、Redis中RDB的持久化方式
- 手动触发保存数据快照和条件触发保存数据快照


















